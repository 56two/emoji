<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #ffffff;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none; /* é˜²æ­¢ç§»åŠ¨è®¾å¤‡ä¸Šçš„é»˜è®¤è§¦æ‘¸è¡Œä¸º */
        }
        
        #instructions {
            position: absolute;
            top: 10px;
            color: #000000;
            font-size: 16px;
            z-index: 10;
            text-align: center;
            padding: 5px;
            /* é€‚åº”ä¸åŒè®¾å¤‡å°ºå¯¸ */
            @media (max-width: 768px) {
                font-size: 14px;
                top: 5px;
            }
        }
        
        canvas {
            border: 1px solid #000000;
            background-color: #e0e0e0;
            width: 95vw;
            height: 85vh;
            touch-action: none; /* é˜²æ­¢ç§»åŠ¨è®¾å¤‡ä¸Šçš„é»˜è®¤è§¦æ‘¸è¡Œä¸º */
        }

        #styleToggle {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            z-index: 10;
        }

        #styleToggle:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="instructions">å•å‡»é¼ æ ‡å¬å”¤å›¾å½¢</div>
    <button id="styleToggle">åˆ‡æ¢æ ·å¼</button>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let currentStyle = 'emojis';
        const styles = ['emojis', 'shapes', 'symbols', 'animals', 'foods', 'sports'];
        const styleNames = {
            'emojis': 'è¡¨æƒ…',
            'symbols': 'ç¬¦å·',
            'animals': 'åŠ¨ç‰©',
            'foods': 'é£Ÿç‰©',
            'sports': 'è¿åŠ¨'
        };

        document.getElementById('styleToggle').addEventListener('click', () => {
            const currentIndex = styles.indexOf(currentStyle);
            currentStyle = styles[(currentIndex + 1) % styles.length];
            document.getElementById('styleToggle').textContent = 
                `åˆ‡æ¢åˆ°${styleNames[styles[(currentIndex + 2) % styles.length]]}`;
        });

        // åˆå§‹åŒ–æŒ‰é’®æ–‡æœ¬
        document.getElementById('styleToggle').textContent = `åˆ‡æ¢åˆ°${styleNames[styles[1]]}`;

        class Emoji {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 20 + 10;
                this.dx = (Math.random() - 0.5) * 4;
                this.dy = -Math.random() * 4;
                this.gravity = 0.2;
                this.bounceFactor = -0.7;
                this.color = `hsl(${Math.random() * 360}, 70%, 50%)`;
                this.setRandomContent();
            }

            setRandomContent() {
                switch(currentStyle) {
                    case 'emojis':
                        this.content = String.fromCodePoint(0x1F600 + Math.floor(Math.random() * 90));
                        break;
                    case 'animals':
                        const animals = ['ğŸ¶', 'ğŸ±', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¯'];
                        this.content = animals[Math.floor(Math.random() * animals.length)];
                        break;
                    case 'foods':
                        const foods = ['ğŸ', 'ğŸ•', 'ğŸ”', 'ğŸŸ', 'ğŸŒ­', 'ğŸ¿', 'ğŸ©', 'ğŸª', 'ğŸ«', 'ğŸ¦'];
                        this.content = foods[Math.floor(Math.random() * foods.length)];
                        break;
                    case 'sports':
                        const sports = ['âš½', 'ğŸ€', 'ğŸˆ', 'âš¾', 'ğŸ¾', 'ğŸ', 'ğŸ‰', 'ğŸ±', 'ğŸ“', 'ğŸ¸'];
                        this.content = sports[Math.floor(Math.random() * sports.length)];
                        break;
                    case 'symbols':
                        const symbols = ['â™¥', 'â™¦', 'â™ ', 'â™£', 'â˜…', 'â˜€', 'â˜', 'â˜‚', 'â˜ƒ', 'â˜„'];
                        this.content = symbols[Math.floor(Math.random() * symbols.length)];
                        this.color = `hsl(${Math.random() * 360}, 70%, 50%)`; // ä¸ºç¬¦å·æ·»åŠ éšæœºé¢œè‰²
                        break;
                }
            }

            draw() {
                if (currentStyle === 'shapes') {
                    this.drawShape();
                } else {
                    this.drawContent();
                }
            }

            drawContent() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = currentStyle === 'symbols' ? 'transparent' : 'white';
                ctx.fill();
                
                // æ ¹æ®ä¸åŒæ ·å¼è°ƒæ•´å­—ä½“å¤§å°
                let fontSize;
                if (currentStyle === 'symbols') {
                    fontSize = this.radius * 2;
                } else {
                    fontSize = this.radius * 1.5;
                }
                
                ctx.font = `${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = currentStyle === 'symbols' ? this.color : 'black';
                
                // ç¡®ä¿ content å­˜åœ¨
                if (this.content) {
                    ctx.fillText(this.content, this.x, this.y);
                }
                ctx.closePath();
            }


            update() {
                this.dy += this.gravity;

                if (this.y + this.radius >= canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.dy *= this.bounceFactor;
                }

                if (this.x + this.radius >= canvas.width || this.x - this.radius <= 0) {
                    this.dx *= this.bounceFactor;
                }

                for (let other of emojis) {
                    if (other !== this && this.distance(other) < this.radius + other.radius) {
                        let dx = this.x - other.x;
                        let dy = this.y - other.y;
                        let distance = Math.sqrt(dx * dx + dy * dy);

                        let overlap = this.radius + other.radius - distance;
                        this.x += (overlap / 2) * (dx / distance);
                        this.y += (overlap / 2) * (dy / distance);

                        let angle = Math.atan2(dy, dx);
                        let sin = Math.sin(angle);
                        let cos = Math.cos(angle);

                        let x = 0, xB = 0;
                        let y = 0, yB = 0;

                        let vxP = this.dx * cos + this.dy * sin;
                        let vyP = this.dy * cos - this.dx * sin;
                        let vxBP = other.dx * cos + other.dy * sin;
                        let vyBP = other.dy * cos - other.dx * sin;

                        let mP = (this.radius ** 2) / 100;
                        let mBP = (other.radius ** 2) / 100;

                        let vxPFinal = ((mP - mBP) * vxP + 2 * mBP * vxBP) / (mP + mBP);
                        let vxBFinal = ((mBP - mP) * vxBP + 2 * mP * vxP) / (mP + mBP);

                        this.dx = vxPFinal * cos - vyP * sin;
                        this.dy = vyP * cos + vxPFinal * sin;
                        other.dx = vxBFinal * cos - vyBP * sin;
                        other.dy = vyBP * cos + vxBFinal * sin;
                    }
                }

                this.x += this.dx;
                this.y += this.dy;
            }

            distance(other) {
                return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
            }
        }

        let emojis = [];

        function handleTouch(event) {
            event.preventDefault(); // é˜»æ­¢é»˜è®¤æ»šåŠ¨è¡Œä¸º
            const rect = canvas.getBoundingClientRect();
            const touch = event.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            spawnEmoji(x, y);
        }

        // ä¿®æ”¹ç°æœ‰çš„ spawnEmojis å‡½æ•°ï¼Œä½¿å…¶æ›´é€šç”¨
        function spawnEmoji(x, y) {
            const count = Math.floor(Math.random() * 3) + 1; // åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šç”Ÿæˆæ›´å°‘çš„emoji
            
            for (let i = 0; i < count; i++) {
                emojis.push(new Emoji(x, y));
            }
        }

        // æ·»åŠ è§¦æ‘¸äº‹ä»¶ç›‘å¬å™¨
        function initEventListeners() {
            // ä¿æŒç°æœ‰çš„ç‚¹å‡»äº‹ä»¶
            canvas.addEventListener('click', (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                spawnEmoji(x, y);
            });
            
            // æ·»åŠ è§¦æ‘¸äº‹ä»¶
            canvas.addEventListener('touchstart', handleTouch, { passive: false });
        }

        function resizeCanvas() {
            // è·å–è®¾å¤‡æ–¹å‘
            const isPortrait = window.innerHeight > window.innerWidth;
            
            // æ ¹æ®è®¾å¤‡æ–¹å‘è°ƒæ•´ç”»å¸ƒå¤§å°
            if (isPortrait) {
                canvas.width = window.innerWidth * 0.95;
                canvas.height = window.innerHeight * 0.80; // åœ¨ç«–å±æ¨¡å¼ä¸‹ç¨å¾®å‡å°é«˜åº¦
            } else {
                canvas.width = window.innerWidth * 0.90;
                canvas.height = window.innerHeight * 0.85;
            }
            
            // è°ƒæ•´ emoji å¤§å°
            const scaleFactor = Math.min(canvas.width, canvas.height) / 800; // åŸºå‡†å°ºå¯¸
            Emoji.prototype.baseRadius = 15 * scaleFactor; // æ›´æ–°åŸºç¡€å¤§å°
            
            // ç¡®ä¿æ‰€æœ‰emojiéƒ½åœ¨æ–°çš„ç”»å¸ƒèŒƒå›´å†…
            emojis.forEach(emoji => {
                if (emoji.x + emoji.radius > canvas.width) {
                    emoji.x = canvas.width - emoji.radius;
                }
                if (emoji.y + emoji.radius > canvas.height) {
                    emoji.y = canvas.height - emoji.radius;
                }
            });
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let emoji of emojis) {
                emoji.update();
                emoji.draw();
            }

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', resizeCanvas);
        initEventListeners();
        resizeCanvas();
        animate();
    </script>
</body>
</html>
