<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #ffffff;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none; /* 防止移动设备上的默认触摸行为 */
        }
        
        #instructions {
            position: absolute;
            top: 10px;
            color: #000000;
            font-size: 16px;
            z-index: 10;
            text-align: center;
            padding: 5px;
            /* 适应不同设备尺寸 */
            @media (max-width: 768px) {
                font-size: 14px;
                top: 5px;
            }
        }
        
        canvas {
            border: 1px solid #000000;
            background-color: #e0e0e0;
            width: 95vw;
            height: 85vh;
            touch-action: none; /* 防止移动设备上的默认触摸行为 */
        }
    </style>
</head>
<body>
    <div id="instructions">单击鼠标召唤emoji</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        class Emoji {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 20 + 10; // Random radius between 10 and 30
                this.dx = (Math.random() - 0.5) * 4; // Horizontal velocity
                this.dy = -Math.random() * 4; // Vertical velocity
                this.gravity = 0.2; // Gravity effect
                this.bounceFactor = -0.7; // Bounce factor after collision
                this.emojiChar = String.fromCodePoint(0x1F600 + Math.floor(Math.random() * 90)); // Random emoji character
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.font = `${this.radius}px serif`;
                ctx.textAlign = 'center';
                ctx.fillText(this.emojiChar, this.x, this.y + this.radius / 3);
                ctx.closePath();
            }

            update() {
                this.dy += this.gravity;

                if (this.y + this.radius >= canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.dy *= this.bounceFactor;
                }

                if (this.x + this.radius >= canvas.width || this.x - this.radius <= 0) {
                    this.dx *= this.bounceFactor;
                }

                for (let other of emojis) {
                    if (other !== this && this.distance(other) < this.radius + other.radius) {
                        let dx = this.x - other.x;
                        let dy = this.y - other.y;
                        let distance = Math.sqrt(dx * dx + dy * dy);

                        let overlap = this.radius + other.radius - distance;
                        this.x += (overlap / 2) * (dx / distance);
                        this.y += (overlap / 2) * (dy / distance);

                        let angle = Math.atan2(dy, dx);
                        let sin = Math.sin(angle);
                        let cos = Math.cos(angle);

                        let x = 0, xB = 0;
                        let y = 0, yB = 0;

                        let vxP = this.dx * cos + this.dy * sin;
                        let vyP = this.dy * cos - this.dx * sin;
                        let vxBP = other.dx * cos + other.dy * sin;
                        let vyBP = other.dy * cos - other.dx * sin;

                        let mP = (this.radius ** 2) / 100;
                        let mBP = (other.radius ** 2) / 100;

                        let vxPFinal = ((mP - mBP) * vxP + 2 * mBP * vxBP) / (mP + mBP);
                        let vxBFinal = ((mBP - mP) * vxBP + 2 * mP * vxP) / (mP + mBP);

                        this.dx = vxPFinal * cos - vyP * sin;
                        this.dy = vyP * cos + vxPFinal * sin;
                        other.dx = vxBFinal * cos - vyBP * sin;
                        other.dy = vyBP * cos + vxBFinal * sin;
                    }
                }

                this.x += this.dx;
                this.y += this.dy;
            }

            distance(other) {
                return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
            }
        }

        let emojis = [];

        function handleTouch(event) {
            event.preventDefault(); // 阻止默认滚动行为
            const rect = canvas.getBoundingClientRect();
            const touch = event.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            spawnEmoji(x, y);
        }

        // 修改现有的 spawnEmojis 函数，使其更通用
        function spawnEmoji(x, y) {
            const count = Math.floor(Math.random() * 3) + 1; // 在移动设备上生成更少的emoji
            
            for (let i = 0; i < count; i++) {
                emojis.push(new Emoji(x, y));
            }
        }

        // 添加触摸事件监听器
        function initEventListeners() {
            // 保持现有的点击事件
            canvas.addEventListener('click', (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                spawnEmoji(x, y);
            });
            
            // 添加触摸事件
            canvas.addEventListener('touchstart', handleTouch, { passive: false });
        }

        function resizeCanvas() {
            // 获取设备方向
            const isPortrait = window.innerHeight > window.innerWidth;
            
            // 根据设备方向调整画布大小
            if (isPortrait) {
                canvas.width = window.innerWidth * 0.95;
                canvas.height = window.innerHeight * 0.80; // 在竖屏模式下稍微减小高度
            } else {
                canvas.width = window.innerWidth * 0.90;
                canvas.height = window.innerHeight * 0.85;
            }
            
            // 调整 emoji 大小
            const scaleFactor = Math.min(canvas.width, canvas.height) / 800; // 基准尺寸
            Emoji.prototype.baseRadius = 15 * scaleFactor; // 更新基础大小
            
            // 确保所有emoji都在新的画布范围内
            emojis.forEach(emoji => {
                if (emoji.x + emoji.radius > canvas.width) {
                    emoji.x = canvas.width - emoji.radius;
                }
                if (emoji.y + emoji.radius > canvas.height) {
                    emoji.y = canvas.height - emoji.radius;
                }
            });
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let emoji of emojis) {
                emoji.update();
                emoji.draw();
            }

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', resizeCanvas); // 监听设备方向变化
        initEventListeners();
        resizeCanvas();
        animate();
    </script>
</body>
</html>
